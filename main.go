package main

// @title User API documentation
// @version 1.0.0
// @BasePath /api/v1

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"math/big"
	"math/rand"
	"net"
	"net/http"
	"os"
	"runtime"
	"strconv"
	"time"

	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus/promhttp"

	_ "github.com/idebrody/learning-webapi-go/docs"

	httpSwagger "github.com/swaggo/http-swagger"
)

// cover aritmetics functions
type arithmetics func(num1 float64, num2 float64) (float64, error)

var GoroutineTreshold int

// Print the documentation
func apidoc(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(`{"message": "get called"}`))
}

// sendParsing error back to the client
func sendParsingError(w http.ResponseWriter, qParam string) {
	w.WriteHeader(http.StatusBadRequest)
	w.Write([]byte(fmt.Sprintf(`{"error": "Invalid number: %s"}`, qParam)))
}

// add ... Add two numbers together
// @Summary Adding numbers
// @Description Take two numbers and add them together
// @Tags add
// @Param num1 query float64 true "first number"
// @Param num2 query float64 true "second number"
// @Success 200 {object} object
// @Failure 400 {object} object
// @Router /add [get]
func add(num1 float64, num2 float64) (float64, error) {
	return num1 + num2, nil
}

// substract ... Substract two numbers
// @Summary Substracting numbers
// @Description Take two real numbers and return the result of subtracting them
// @Tags substract
// @Param num1 query float64 true "first number"
// @Param num2 query float64 true "second number"
// @Success 200 {object} object
// @Failure 400 {object} object
// @Router /substract [get]
func substract(num1 float64, num2 float64) (float64, error) {
	return num1 - num2, nil
}

// division ... Divide two numbers together
// @Summary Divide numbers
// @Description Divide two numbers, return the result
// @Tags division
// @Param num1 query float64 true "first number"
// @Param num2 query float64 true "second number"
// @Success 200 {object} object
// @Failure 400,404 {object} object
// @Router /division [get]
func division(num1 float64, num2 float64) (float64, error) {
	if num2 == 0 {
		return 0, errors.New("Division by Zero")
	}
	return num1 / num2, nil
}

func math(w http.ResponseWriter, r *http.Request, fn arithmetics) {

	w.Header().Set("Content-Type", "application/json")
	query := r.URL.Query()
	//TODO: error handling
	num1, err := strconv.ParseFloat(query.Get("num1"), 64)
	if err != nil {
		sendParsingError(w, query.Get("num1"))
		return
	}

	num2, err := strconv.ParseFloat(query.Get("num2"), 64)
	if err != nil {
		sendParsingError(w, query.Get("num2"))
		return
	}

	retVal, err := fn(num1, num2)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(fmt.Sprintf(`{"error": "%s"}`, err)))
		return
	}
	w.WriteHeader(http.StatusOK)
	// Doing some precision rounding
	// ToDo: might have been better if I used the math/big from the start
	w.Write([]byte(fmt.Sprintf(`{"result": %s}`, big.NewFloat(retVal).String())))
}

// random ... Return random numbers
// @Summary Get random numbers
// @Description Get random numbers
// @Tags random
// @Param Count query int false "Amount of random numbers to return"
// @Success 200 {array} int
// @Failure 400,404 {object} object
// @Router /random [get]
func random(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	countStr := r.URL.Query().Get("Count")
	var count int
	if countStr == "" {
		count = 10
	} else {
		var err error
		count, err = strconv.Atoi(countStr)
		// conversion error
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte(fmt.Sprintf(`{"error": "Invalid integer for Count: %s"}`, countStr)))
			return
		}

		if count < 0 {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte(fmt.Sprintf(`{"error": "Count must be positive: %s"}`, countStr)))
			return
		}
	}

	rand.Seed(time.Now().UnixNano())
	randomArray := make([]int, count)
	for i := 0; i < count; i++ {
		randomArray[i] = rand.Int()
	}
	// given this was generated by the method, no need for error checking
	resultJson, _ := json.Marshal(randomArray)
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(resultJson))
}

// https://github.com/heptiolabs/healthcheck/blob/master/checks.go
func GoroutineCountCheck() error {
	count := runtime.NumGoroutine()
	if count > GoroutineTreshold {
		return fmt.Errorf("too many goroutines (%d > %d)", count, GoroutineTreshold)
	}
	return nil
}

func liveness(w http.ResponseWriter, r *http.Request) {
	err := GoroutineCountCheck()
	if err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusServiceUnavailable)
		w.Write([]byte(fmt.Sprintf(`{"error": "%s"}`, err)))
		return
	}
	w.WriteHeader(http.StatusOK)
}

// Not sure if there is any readiness check I could do with the go module to be honest,
// so just implemented port check
func readiness(w http.ResponseWriter, r *http.Request) {
	timeout := 1 * time.Second
	conn, err := net.DialTimeout("tcp", "localhost:8080", timeout)
	defer conn.Close()
	if err != nil {
		//log.Println("Site unreachable, error: ", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
}

func opendocs(w http.ResponseWriter, r *http.Request) {
	http.Redirect(w, r, "/docs/", 301)
}

func notSupported(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusMethodNotAllowed)
	w.Write([]byte(`{"message": "only GET is allowed"}`))
}

// golan init function
func init() {
	var gTresholdStr = os.Getenv("GOROUTINETRESHOLD")
	if gTresholdStr == "" {
		GoroutineTreshold = 100
	} else {
		var err error
		GoroutineTreshold, err = strconv.Atoi(os.Getenv("GOROUTINETRESHOLD"))
		if err != nil {
			log.Fatal(fmt.Sprintf(`{"error": "%s"}`, err))
		}
	}
}

func main() {
	r := mux.NewRouter()
	api := r.PathPrefix("/api/v1").Subrouter()

	api.HandleFunc("/add", func(w http.ResponseWriter, r *http.Request) { math(w, r, add) }).Methods(http.MethodGet)
	api.HandleFunc("/substract", func(w http.ResponseWriter, r *http.Request) { math(w, r, substract) }).Methods(http.MethodGet)
	api.HandleFunc("/division", func(w http.ResponseWriter, r *http.Request) { math(w, r, division) }).Methods(http.MethodGet)
	api.HandleFunc("/random", random).Methods(http.MethodGet)
	// Using the The official Golang Prometheus library, not sure if that defeats the point of the exercise ¯\_(ツ)_/¯
	r.HandleFunc("/", opendocs).Methods(http.MethodGet)
	r.PathPrefix("/docs/").Handler(httpSwagger.WrapHandler)
	r.Path("/metrics").Handler(promhttp.Handler())
	r.HandleFunc("/liveness", liveness).Methods(http.MethodGet)
	r.HandleFunc("/readiness", readiness).Methods(http.MethodGet)
	api.HandleFunc("/", notSupported)
	log.Fatal(http.ListenAndServe(":8080", r))

}
